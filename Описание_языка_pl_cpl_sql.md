<h2>Описание возможностей языка (pl_cpl_sql), для которого разработан интерпретатор:</h2>

<h3>1)	По синтаксису он похож на Oracle PL/SQL.</h3>

<h3>2)	В одном программном коде поддерживается несколько соединений с различными базами данных.</h3>
	<p>В общем смысле исполняемый программный код не привязан к конкретной БД. Каждый SQL-оператор (select/update/delete...) в своем описании
		должен иметь метку вида <b>/*##db=dbname##*/</b>, в которой указано название соединения с БД (поддерживаются соединения с БД PostgreSQL и Oracle). 
		Сами параметры соединения указаны в файле - <b>conn_params.json</b>, который определен заранее и размещен на сервере БД. 
		В момент выполнения кода создается нужное соединение и в нем выполняется SQL-оператор.
		</p>

<h3>3)	Поддерживает следующие типы данных:</h3> 
	<ul>
		<li><b>VARCHAR2</b> - Этот тип данных хранит строку. Если указана длина строки - то будет происходить проверка длины в коде, 
		если длина не указана - то можно записывать данные длиной не более 100000000.</li>
		<li><b>INTEGER</b> -  Этот тип данных используется для работы с полями, которые будут содержать только числовые данные.</li>
		<li><b>NUMBER</b> - Этот тип данных используется для работы с полями, которые будут содержать только числовые данные с фиксированной или плавающей точкой.</li>
		<li><b>DATE</b> - Этот тип данных хранит значения в формате даты (dd.mm.yyyy hh24:mi:ss).</li>
		<li><b>JSON</b> - Этот тип данных является форматом для хранения и передачи данных в форме объектов, массивов и других значений, которые можно легко преобразовать в текстовую строку.</li>
		<li><b>RECORD</b> - Этот тип данных похож на переменную строкового типа, но он не имеют предопределённой структуры. 
		Он приобретают фактическую структуру от строки, которая им присваивается командами SELECT или FOR. Структура переменной типа record может меняться каждый раз при присвоении значения.</li>
		<li><b>BOOLEAN</b> - Этот тип данных хранит логические значения (true/false).</li>
	</ul>

<h3>4)	Поддерживает работу с курсорами.</h3>
	<p>Курсор – это средство извлечения данных из базы данных. Курсоры содержат определения столбцов и объектов (таблиц, представлений и т.п.) из которых будут извлекаться данные, а также набор критериев, определяющих какие именно строки должны быть выбраны.<br>Пользователю доступны следующие способы выполнения запроса к базе данных:</p>
		<ul>
			<li><b>Неявные курсоры</b> - простой оператор SELECT ... INTO извлекает одну строку данных непосредственно в переменные локальной программы. Это удобный (и часто наиболее эффективный) способ доступа к данным, использование которого, однако, может приводить к необходимости повторного кодирования оператора SELECT (или похожих операторов) в нескольких местах программы.</li>
			<li><b>Явные курсоры</b> - вы можете явно объявить курсов в разделе объявлений. В этом случае курсор можно будет открывать и извлекать данные в одной или нескольких программах, причем возможности контроля будут шире, чем при использовании неявных курсоров.</li>
		</ul>		
		
<h3>5) Реализованы операторы FOR, WHILE, OPEN, IF.</h3>
	<ul>		
		<li>Операторы цикла: <b>FOR, LOOP, WHILE.</b></li>
		<li>Условный оператор: <b>IF THEN ELSE.</b></li>
		<li>Оператор: <b>OPEN FETCH.</b></li>
	</ul>			
		
<h3>6)	Имеются следующие встроенные пакеты:</h3>
	<div style="margin-left: 30px;">	
	<h4>a). TEXT_IO - для работы с локальными файлами (можно работать только с файлами, расположенными в папках на сервере БД).</h4>		
	<p>Он содержит следующие методы:</p>
	<ul>
		<li><b>text_io.fopen( 'полный путь к файлу','ключ',кодировка)</b> - Открытие файла. Ключ содержит следующие значения - 
		'r' - только чтение файла, 'w' - только запись в файл. Кодировка - UTF8 или ANSI.</li>
		<li><b>text_io.count_lines(file1)</b> - Прочитать количество строк из файла.</li>
		<li><b>text_io.get_line(file1, index)</b> - Прочитать строку из файла по индексу (index).</li>			
		<li><b>text_io.get_file_content(file1)</b> - Прочитать все содержимое файла.</li>						
		<li><b>text_io.put_line(file1, 'строка')</b> - Записать строку в файл.</li>
		<li><b>text_io.fclose(file1)</b> - Закрытие файла.</li>
	</ul>
	<h4>b). HTTP_IO - для работы с http/https.</h4>
	<p>Он содержит следующие методы:</p>
	<ul>
		<li><b>http_io.begin_request(url, method)</b> - инициализация переменной.</li>
		<li><b>http_io.set_header(http_req, 'ключ', 'значение')</b> - установить заголовок.</li>
		<li><b>http_io.set_resp_encoding(http_req, 'UTF8')</b> - установить кодировку ответа.</li>
		<li><b>http_io.write_text(http_req, 'тело отправляемого сообщения')</b> - установить тело отправляемого сообщения.</li>
		<li><b>http_io.get_response(http_req)</b> - перейдем по url и получим ответ.</li>
		<li><b>status_code</b> - код ответа</li>
		<li><b>response_text</b> - текст ответа</li>
	</ul>
	<h4>c). Пакет JSON_IO - для работы с JSON-объектами.</h4>		
	<p>Он содержит следующие методы:</p>
	<ul>
		<li><b>json_io.add(js_obj1, 'ключ', 'значение')</b> - добавить в json-объект пару ключ-значение.</li>
		<li><b>json_io.format(js_obj1)</b> - вывод json-кода в отформатированном виде.</li>
		<li><b>json_io.record_to_json(rec)</b> - преобразовать значение переменной типа record в json-формат.</li>
		<li><b>json_io.count_keys(js_obj1)</b> - вывести количество пар ключ-значение.</li>
		<li><b>json_io.count_rows(js_obj1)</b> - вывести количество значений внутри json-массива.</li>
		<li><b>json_io.get_key_name(js_obj1, index)</b> - вывести название ключа по индексу (index).</li>
		<li><b>json_io.get_key_value(js_obj1, index)</b> - вывести значение ключа по индексу (index).</li>
		<li><b>json_io.get_row(js_obj1, index)</b> - вывести json-код элемента массива по индексу (index).</li>
	</ul>		
	<h4>d). Пакет RECORD_IO - для работы с переменными типа record.</h4>		
	<p>Он содержит следующие методы:</p>
	<ul>
		<li><b>record_io.add_field(rec1, ['название_поля', 'тип_поля'])</b> - добавить в переменную типа record новое поле (новые поля...).</li>
		<li><b>record_io.print_record(rec1)</b> - вывод содержимого переменной типа record (rec1).</li>
		<li><b>record_io.json_to_record(obj1, rec1)</b> - преобразовать значение переменной типа json (obj1) в переменную типа record (rec1).</li>
	</ul>
	</div>
	<h4>e). Пакет XML_IO - для парсинга (разбора) XML - документов.</h4>		
	<p>Он содержит следующие методы:</p>
	<ul>
		<li><b>xml_io.get_node_count(xml_doc)</b> - получить количество разобранных вершин xml-документа. После разбора xml-документа вершины помещаются во внутренний массив.</li>
		<li><b>xml_io.get_node_prop(xml_doc, ind, prop_name)</b> - получить значение свойства вершины (ind - индекс вершины в массиве, prop_name - ('name', 'value', 'path', 'type', 'level') - название свойства).</li>
		<li><b>xml_io.get_node_attr(xml_doc, ind, attr_name)</b> - получить значение атрибута вершины (ind - индекс вершины в массиве, attr_name - название атрибута).</li>
		<li><b>xml_io.get_node_all_attr(xml_doc, ind)</b> - получить значения всех атрибутов вершины (ind - индекс вершины в массиве).</li>		
	</ul>
	</div>	
	<h4>f). Пакет HTML_IO - для парсинга (разбора) HTML - документов.</h4>		
	<p>Он содержит следующие методы:</p>
	<ul>
		<li><b>html_io.get_node_count(xml_doc)</b> - получить количество разобранных вершин html-документа. После разбора html-документа вершины помещаются во внутренний массив.</li>
		<li><b>html_io.get_node_prop(xml_doc, ind, prop_name)</b> - получить значение свойства вершины (ind - индекс вершины в массиве, prop_name - ('name', 'value', 'path', 'type', 'level') - название свойства).</li>
		<li><b>html_io.get_node_attr(xml_doc, ind, attr_name)</b> - получить значение атрибута вершины (ind - индекс вершины в массиве, attr_name - название атрибута).</li>
		<li><b>html_io.get_node_all_attr(xml_doc, ind)</b> - получить значения всех атрибутов вершины (ind - индекс вершины в массиве).</li>		
	</ul>
	</div>		

<h3>7)	Реализован оператор EXECUTE для выполнения произвольного текста.</h3>

<h3>8)	Реализованы различные встроенные функций.</h3>
	<ul>
		<li><b>dbms_output.put_line(text)</b> - вывод текстового сообщения.</li>
		<li><b>upper(text)</b> - перевод текста в верхний регистр.</li>
		<li><b>lower(text)</b> - перевод текста в нижний регистр.</li>
		<li><b>rtrim(text)</b> - отрезать пробелы справа.</li>			
		<li><b>ltrim(text)</b> - отрезать пробелы слева.</li>			
		<li><b>trim(text) </b> - отрезать пробелы со всех сторон.</li>			
		<li><b>replace(text, text_to_replace, replacement_text) </b> - замена текста по образцу.</li>			
		<li><b>substr(text, start_position, length) </b> - извлечь подстроку из строки.</li>						
		<li><b>instr(text, substring) </b> - возвращает n-е вхождение подстроки в строке.</li>									
		<li><b>length(text) </b> - возвращает длину строки.</li>												
		<li><b>chr(number_code) </b> - возвращает символ, который основан на числовом коде.</li>															
		<li><b>sysdate </b> - получение текущей даты и времени.</li>																		
	</ul>
	
<h3>9)	В папке \Examples есть примеры кода.</h3>	
